# 总架构

​		共有三个类共同合作完成IO复用功能：

- Channel类（==句柄 + 事件处理器==）
  - 首先作为句柄（Handle），实现对文件描述符上事件的封装，维护文件描述符上的事件，并提供向事件分发器注册/注销事件的方法。
  - 其次作为事件处理器，它绑定各种事件对应的处理函数，并根据事件分发器返回来就绪事件调用相应的处理函数。
- EventLoop类（==事件分发器/句柄集==）：它聚合大量的Channel类，利用系统提供的IO复用机制检测句柄（Channel）上的事件，在有事件发生后调用句柄提供的事件处理函数。
- Poller类层次：时间分发器的底层实现（相当于Impl类），完成对系统IO复用机制的封装，包括向系统注册/注销句柄对应的事件。调用系统的IO复用函数，并在事件到来时返回已就绪事件对应的句柄。



# Channel类分析

- 作为句柄，它应包含其管理的文件描述符、即关注的事件和就绪的事件，并提供注册/注销事件的方法，该方法将由事件分发器EventLoop调用其底层Poller的实现，将文件描述符上关注的时间注册到系统内核。

- 作为事件处理器，其需含有事件处理回调函数，并提供相应的设置接口。同时实现一个事件处理函数供事件分发器调用，该函数根据上层返回的就绪时间调用相应的回调函数。



# EventLoop类分析

​		作为事件分发器，其聚合大量的句柄（Channel），并提供向系统内核注册事件的调用的方法（交由底层实现Poller具体完成）。同时需要提供一个事件分发的函数，该函数的具体功能有：

1. 调用系统底层的IO复用函数实现对事件的监听（交由底层实现Poller完成）

2. 根据返回的活跃的句柄（存在就绪时间），依次调用句柄的事件处理函数。

​        作为网络库，它应关注的事件有：I/O事件（包括网络I/O(socket)、事件IO(eventfd)）、定时事件（timerfd）。

- 对于网络I/O，事件分发器不进行任何处理工作，交由句柄绑定的业务逻辑处理回调函数来完成。
- 对于事件I/O，它通常用于唤醒IO复用函数，以使一些工作得到及时的处理。所以时间分发器应当提供一个时间处理函数来处理事件I/O，防止忙唤醒。
- 对于定时事件，它与网络I/O相同，将事件交由注册定时事件时绑定的定时事件函数来完成。需提供响应的定时设置接口，但具体的实现可以交由专门的定时管理类来实现。

