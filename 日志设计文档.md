# 日志设计文档

# 1、Logger

主要功能：只负责对用户接口的封装，其具体的实现交由其他类来负责。

输出的信息：日期  时间  微秒  线程tid  日志级别 （errno即对应的信息）(函数名)   日志信息  源文件名：行号



## 1.1 日志的级别

​		需要对日志级别进行设计划分，为简单所有线程均使用相同的日志级别，在程序的配置阶段进行设置，运行阶段应只读以保证线程安全。级别可分为以下几种：

- DEBUG：细粒度的信息事件，以便调试、诊断应用程序。
- INFO：粗细粒度的信息时间，强调软件的运行过程。
- WARNING：表明意想不到的事情发生，虽然目前能正常工作，但是可能存在潜在的风险。
- ERROR：更严重的问题，软件没能执行一些功能。
- FATAL：严重的错误，软件无法继续运行。

应包含的内容：

- **enum LogLevel**的定义
- 声明一个**全局的LogLevel**并提供初始化的函数:**initLogLevel**
- 提供日志级别的**getter和setter方法**。



## 1.2 日志输出对象（Appender）

​		需要明确日志的输出对象，为了简化，仅有一个全局的对象，并且输出对象默认提供向命令行输出，但是也可以通过setter方法将输出进行重定向。

应包含的内容：

- 全局的输出函数对象（或者指针），默认指向标准输出。
- **setter方法**，可以完成输出的重定向。
- 立即刷新输出流的**flush方法**。



【注】其他的一些想法：可以在Logger类的构造函数中引用参数，通过与传入参数建立关联的方式实现运行期将日志文件输出到不同的目的。



## 1.3 内部实现Impl

​		Impl完成具体日志信息的格式化工作，根据日志需要输出的信息，Impl需要格式化：日期、时间、微秒、日志的级别、errno及其对应的信息、函数名、源文件名、行号。其他的部分的信息已经由其他的模块准备好。

- 日期、时间与微秒：**formatTime(bool useUTC)**格式化日期，为了提高效率，同一秒的多个日志只需重新格式化微秒即可。（默认使用UTC时间）
- 日志的级别可以通过字符串哈希数组来完成。
- strerror_
- 函数名、源文件名、行号可以通过gcc内置的宏来实现。



# 2、LogStream

​		对输出流缓存的封装，**Impl内含一个LogStream对象，将格式好的数据插入缓存中**。最后**由前端的Logger统一的输出到Appender定向到的目的输出**。



应包含的内容：

- 对各种类型数据重载的operator << 方法，在内部转化为字符串的形式并调用内置缓冲区的append追加到缓冲区中。
- 返回内含的缓冲区对象。
- 重置缓冲区指针。



## 2.1、 FixedBuffer

​		对缓冲区的Buffer封装，默认大小为4KB，封装对字符缓冲区的操作。提供给LogStream对象使用，LogStream仅需**重载插入流**的方法及**返回缓冲区**和长度的方法即可。



应包含的内容：

- append方法用于向缓冲区追加数据：append(const char*, size_t)
- add(size_t):移动缓冲区的指针，通常用于追加后移动指针使用
- data()、current()、end()、avail()、length()：返回缓冲区的头部位置、当前位置、缓冲区末尾、缓冲区可用大小和当前已缓存的长度。
- 清空/重置缓冲的操作bzero()、reset()
- 转化为字符串的方法toString()、toStringPiece()



# 3、LogFile

​		LogFile是日志文件的封装，其需包含回滚功能，回滚的条件包括两个：

- 大小——当日止文件大小达到阈值后就回滚一个新的日志文件。

- 时间——比如新的一天就回滚一次，无论当前日志文件是否写满。

LogFile与上述日志体制的进行交互唯一方式是与Appender进行交互。在程序配置阶段重定向Appender的输出目的地为LogFile文件。

​		典型的日志文件名为：logfile_test.20211001-191300.hostname.3605.log

- 第一部分logfile_test是进程的名字。通常是argv[0]的basename(3)，以区分究竟是哪个服务程序的日志
- 第二部分是文件创建的时间（UTC时间）。以容易通过文件名来选择某一时间范围的日志。
- 第三部分是机器名称。这样即便把日志拷贝到其他机器也能追溯其来源。
- 第四部分是进程id
- 第五部分是统一的后缀.log

往文件写日志的常见问题是，玩意程序崩溃就会导致最后的若干条日志丢失，因为日志库不能每条消息都flush硬盘。采用的解决方法是定期（3秒）将缓冲区的日志flush到硬盘，同时为了兼顾效率在写一定数量的日志消息之后才去检查超时时间。



应包含的内容：

- 往日志文件追加的功能append(const char* logline, size_t len)。需判断当前是否需要滚动新的日志文件（日志的记录次数与时间）。
- 刷新缓冲区的功能flush()
- 日志文件滚动的功能rollingFile()。

注意LogFile应当也是单例。





# 4、异步日志

​		上述的的日志属于同步日志，即调用一次日志输出就会立即将日志消息输出到对应的目的地，默认为终端，但是这样每次都会调用系统函数而使当前线程陷入内核，而这种方式是非常低效的，即便使用LogFile（其内部包含一个AppendFile），每次进行也如也会调用fwrite_unlock，相对来说也比较耗时。频繁的调用IO函数是高性能服务器的杀手。

​		一个解决方法是异步日志：分为前端和后端，其主要功能是

- 所有线程的日志操作都只与前端进行交互，前端并不直接将其写入文件，而是将其写入缓冲区中（比如LogStream中的FixedBuffer），将Buffer的容量调大，每次都将写入的日志推入到前端的Buffer中，在满足一定条件的情况下将Buffer交给后端
- 后端唯一的操作就是等待某个条件的到达，然后取得前端缓冲区里的Buffer，将其写入日志文件。

这样，所有线程与前端交互都是非阻塞操作，且仅仅是将日志数据推入缓冲区，而不调用IO函数，大大提高了效率。只有后端的日志线程负责将写满日志的缓冲区写入文件（利用LogFile），并且由于只有单线程操作LogFile，所以LogFile不需要是线程安全的，这样也节省了线程同步所带来的开销。

​		上述某个条件应满足：

- 首先，前端的缓冲区写满了应当通知后端线程。
- 如果日志量不大，会导致很长一段时间不会写日志文件，此时如果中间发生意外，服务器down掉了，那么缓存的还未写入的日志数据将会丢失，而这些数据也是比较重要的。因此，即便缓冲区未满，也需要在一段时间通知后台日志线程写日志文件，因此默认时间为3s。

注意到异步日志在一个服务进程中一般只会有一个，因此可以用单例来实现。



具体的异步日志应当包括：

- 与前端交互的接口：
  - append(const char* logline, size_t len)：向前端缓冲区追加日志消息。
  - start()和stop()用来启动/停止异步日志。
- 后端：在创建异步日志使创建一个单独的后端线程，并设置其routine为threadFunc，使用条件变量等待前端线程的通知，完成写入日志文件的功能。



​		具体的实现为4个缓冲区（FixedBuffer<kLargeBufferSize>），前端2个currentBuffer\_,nextBuffers\_，前端线程将日志消息添加到currentBuffer\_中，如果currentBuffer\_已满，则将currentBuffer\_替换为nextBuffer\_,这样节省了分配内存带来的开销，并立即通知后端线程写日志文件。

​		而后端线程也有两个缓冲区newBuffer1\_，newBuffer2\_，线程等待前端线程通知或者周期时间超时，然后将前端的currentBuffer\_也取到，并利用swap on write的手法将临界区缩到最小，然后利用两块缓冲区补充前端的缓冲区后，释放锁，在写日志文件并补充后端的两个缓冲区。

